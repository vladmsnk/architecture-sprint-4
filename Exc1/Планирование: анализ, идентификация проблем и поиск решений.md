## 1.1 Проанализируйте схему и описание системы.

### Текущая схема состоит из:
- Монолитный бэкенд ShopAPI.
- Монолитный бэкенд MES.
- Один экземпляр очереди RabbitMQ.
- Общий экземпляр СУБД для ShopAPI и CRM.
- Монолитный фронтенд Internet Shop.
- Монолитный фронтенд MES.
- Информация по операторам и данным MES хранится в СУБД MES.

### 1.2 Текущие проблемы архитектуры
1) Создание заказов, отображение списка товаров, работа в редакторе и загрузка файлов — все это обрабатывается одним 
фронтендом и одним бэкендом, что может негативно повлиять на производительность.
   - Редактор может требовать большое количество RAM для генерации изображений. 
В то время как обработка заказов может требовать большое количество CPU.
   - Загрузка файлов может негативно сказываться на производительности других операций, если загружаются большие файлы. 
Более того, если операция загрузки файлов производится синхронно, то это может заставлять ждать другие операции.
   - Сервис ShopAPI не может масштабироваться горизонтально, так как он монолитный. 
Нет ясности того, какие части можно масштабировать, а какие нет. Масштабирование отдельных компонент также невозможно, 
так как в сервисе присутствует жесткая связанность компонент.
   - Более того, графический редактор интегрирован в тот же фронтенд, где происходят операции с заказами. 
Это может влиять на быстродействие отдельных компонент фронтенда.
Например, если графический редактор активно используется большим количеством пользователей, загрузка страницы с заказами может замедлиться.
2) CRM API использует тот же экземпляр СУБД, что и ShopAPI. 
   - Это усложняет работу с данными из-за того, что в одном экземпляре по сути находится две разные схемы данных. 
Более того, эти 2 схемы данных могут быть жестко связаны между собой из-за чего изменения в одной схеме могут привести к ошибкам в другой.
   - Большая награзука на СУБД со стороны сервиса Shop API может привести к тому, что CRM API будет работать медленнее. 
То есть на стабильность сервиса CRM API влияет нагрузка совершенно другого сервиса с другими процессами
   - Отказ экземпляра СУБД приводит к недоступности обоих сервисов.
   - В итоге CRM API жестко связан с Shop API, что затрудняет их масштабирование.
3) Единственный экземпляр RabbitMQ
   - Является узким местом из-за того, что повышенная нагрузка на него может привести к тому, что сообщения будут обрабатываться медленно.
4) Немасштабируемые операции сервиса MES
   - подсчет стоимости заказа является тяжелой операцией, которая требует больших вычислительных мощностей. 
   - Большое количество одновременных запросов на подсчет стоимости заказов влияет на все остальные операции сервиса MES.
   - Из-за чего Операторы могут сталкиваться с проблемой долгой загрузкой страницы с заказами
5) Проблемы с сервисом User API 
   - Заказы, приходящие из сервиса User API, создаются только после расчета стоимости этого заказа. 
   - Запросы на подсчет заказов из User API и пользовательские заказы из Shop API никак не разграничены. 
   Это приводит к тому, что заказы с более высоким приоритетом могут не обрабатываться вовремя.
6) Логика отправки уведомлений интегрирована в текущие сервисы
7) S3 хранилище
   - сейчас файлы 3D моделей хранятся в S3 хранилище без удаления после обработки заказов
   - возможно накопления большого количества файлов, которые уже неактульны, 
   но при этом занимают место и влияют на производительность
### 1.3 Необходимые инициативы 

Определим целевую систему: микросервисная архитектура, спроектированная на основе Event Driven Architecture

Ключевые контейнеры целевой системы:
- ShopService — микросервис декомпозированный из текущего монолита ShopAPI. 
Отвечает только за операции, связанными с сущностью "Заказ"
- EditorService — бэкенд сервис, отвечающий за загрузку файлов и работу редактора 3D моделей
- CRM service — текущий сервис CRM, но со своим собственным экземпляром СУБД. Отвечает за управление данными клиентов
- MES API и Mes Worker — микросервис декомпозированный из текущего монолита MES API. 
  - Mes Worker — сервис, отвечающий за подсчет стоимости заказов
  - MES API — сервис, отвечающий за обработку запросов на подсчет стоимости заказов
- Operator Management Service — микросервис декомпозированный из текущего монолита MES API
Отвечает только за управление процессами, связанными с работой операторов
- API Gateway — единая точка входа в приложение
- Notification Service —  сервис отправки уведомлений 
- Event Bus - RabbitMQ, в будущем возможен переход на Kafka

Инициативы:
1) Первый этап Рефакторинга сервиса MES API. Достижение стабильности системы. 
   - Реализация асинхронного подсчета стоимости заказов с учетом приоритетов
   - Реализация двух видов очереди:
     - Regular — обработка запросов на подсчет стоимости заказов, приходящих из Shop API
     - Priority — обработка запросов на подсчет стоимости заказов, приходящих из User API
   - Обновление Shop Service для подписки на событие OrderPriceCalculated.
   - Разделение сервиса MES на MES API и MES Worker
   - Создание Worker-сервиса для подсчета стоимости заказов (stateless), который можно масштабировать независимо от MES API.

2) Второй этап рефакторига сервиса MES API.
   - Реализация сервиса Operator Management Service
   - Миграция данных, относящихся к операторам, из MES db в Operator Management Service db
   - Переход на использование сервиса Operator Management Service
   - Внедрение Role-Based Access Control для операторов.

3) Перевод сервиса CRM на отдельный экземпляр СУБД
   - Миграция данных по клиента из Shop DB в отдельный экземпляр CRM db

4) Перенос логики работы с редактором из ShopService в отдельный микросервис Editor Service
   - Перенос логики обработки файлов и генерации 3D-моделей из ShopService.
   - Отправка события FileUploaded после успешной загрузки и обработки файла.
   - Интеграция с MES для запуска асинхронного подсчета стоимости заказа по событию FileUploaded.

5) Разработка сервиса Notification Service
   - Отправка уведомлений о заказах и операциях с заказами

6) Переход на Event Driven Architecture
   - полный переход на событийно ориентированную архитектуру
   - связь всех сервис через событийную шину RabbitMQ
   - События:
     - после загрузки файла, отправляется событие FileUploaded
     - после подсчета стоимости заказа, отправляется событие OrderPriceCalculated
     - после получения сервисом Shop Service события OrderPriceCalculated, появляется возможность создать заказ
     - создание заказа порождает событие OrderCreated, на которое подписывается сервис CRM API
     - сотрудники CRM API видят новый заказ и могут подтвердить его либо отклонить. Отправляется событие OrderConfirmed или OrderRejected
     - событие OrderConfirmed получает сервис Operator Management Service, тем самым операторы видят, что появился новый заказа

7) Маршрутизация сервисов через API Gateway
   - Все запросы к сервисам будут проходить через API Gateway

8) Автоматическое масштабирование сервиса MES 
   - перевод инфраструктуры на Kubernetes

9) Примерный подсчет стоимости заказа

10) Обеспечение отказоустойчивости шины данных
    - нам важно, чтобы все события были гарантированно доставлены и обработаны. 
    Неудачная обработка сообщений может привести к тому, что заказы будут завершены, но не доставлены клиенту.
    - добавление очереди Dead Letter Queue для помещения сообщений, которые не удалось обработать:
        - определить оптимальное время жизни сообщения в очереди
        - определить максимальное количество попыток обработки сообщения
    - кластеризация RabbitMQ или переход на Kafka

11) Оптимизация работы с данными
    - интеграция кэширования данных
    - реализация механизма репликации данных

### 1.4 Расстановка приоритетов по текущим инициативам

Приоритеты по методу MoSCoW

Must have:
- Первый этап рефакторинга MES API
- Второй этап рефакторинга MES API
- Перенос логики работы с редактором в Editor Service
- Обеспечение отказоустойчивости шины данных
Should have:
- Переход на Event-Driven Architecture
- Перевод сервиса CRM на отдельный экземпляр СУБД
- Разработка сервиса Notification Service
- Разработка сервиса Маршрутизация сервисов через API Gateway
Could-have:
- Автоматическое масштабирование сервиса MES
- Оптимизация работы с данными
Won't have:
- Примерный подсчет стоимости заказа

- Какой вы видите целевую архитектуру через полгода?

Реализованы все пункты из Must have и Should have

- 3 пункта, которые будут выполняться впервую очередь

- Первый этап рефакторинга MES API
- Второй этап рефакторинга MES API
- Перенос логики работы с редактором в Editor Service

