#### Анализ системы

Места в системе, которые стоит закэшировать:
1) Список товаров Shop DB, если эти товары обновляются редко
2) Кэшировать список заказов
3) Кэшировать промежуточные результаты при использовании 3D редактора
4) Кэшировать список заказов для операторов 
5) Кэшировать загруженные файлы 3D-моделей, так как они дальше будут использоваться при расчете стоимости заказа
6) Кэшировать результат рендеринга готовых 3D-моделей

#### Мотивация

В системе наблюдаются проблемы с производительностью, которые снижают удовлетворенность клиентов. 
Например, страницы с товарами и заказами загружаются долго, а операторы сталкиваются с задержками при работе с заказами. 
Внедрение кэширования — это относительно недорогой способ улучшения производительности, который позволит сократить время загрузки. 
Это, в свою очередь, положительно отразится на ключевых бизнес-метриках.

#### Предлагаемое решение

Используемые паттерны кэширования:

1) **Кэширования списка товаров Shop DB:**
- Паттерн — Write-Through

- Обоснование выбора паттерна — вероятно, список товаров будет обновляться редко.
Обновление товара не требует низкой латентности, поэтому допускается запись данных через кэш. 
Однако, консистентность данных важна, поэтому асинхронное обновление данных в базе недопустимо

- Способ инвалидации — инвалидация по ключу при каждом изменении или удалении товара. Нет смысла инвалидировать весь кэш,
так как произошло точечное изменение определенного товара. Инвалидация по TTL также не подходит, так как товар может
вообще не меняться, но постоянно будет пропадать из кэша.

- Дополнительно возможно использование кэширование на стороне клиента с привязкой кэша к сессии.
Это позволит предотвратить частые запросы на бэкенд при обновлении страниц.
Кэш на стороне клиента будет инвалидироваться проставлением параметра TTL

2) **Кэшировать список заказов**
- Паттерн — Cache-Aside

- Обоснование выбора паттерна — статусы заказов будут меняться часто,
поэтому запись данных через кэш может ухудшить производительность. 
При этом чтение заказов будет происходить чаще, чем их обновление. 

- Способ инвалидации — инвалидация по ключу при каждом изменении статуса заказ. Точечное изменение — не
затрагивает все остальыне заказы, поэтому нет смысла в других способах инвалидации. Для простой реализации алгоритма 
допускается использовать инвалидацию по TTL. 

- Дополнительно возможно использование кэширование на стороне клиента с привязкой кэша к сессии.
  Это позволит предотвратить частые запросы на бэкенд при обновлении страниц.
  Кэш на стороне клиента будет инвалидироваться проставлением параметра TTL

Описание процесса:

Чтение:
1. Shop UI отправляет запрос на список заказов в Shop API. 
2. Shop API проверяет наличие данных в кэше.
   - Если данные есть (cache hit), они возвращаются в результате.
   - Если данных нет (cache miss), Shop API запрашивает их в базе данных.
3. При cache miss:
   - Shop API получает данные из Shop DB.
   - Shop API обновляет кэш актуальными данными из базы данных.

Запись:
1. Shop UI отправляет запрос на изменение статуса заказа в Shop API.
2. Shop API обновляет статус заказа в Shop DB. 
3. После успешного обновления Shop API инвалидирует данные, связанные с этим заказом, из кэша.


3) **Кэшировать промежуточные результаты при использовании 3D редактора**
- Паттерн — кэширование на стороне клиента

- Обоснование выбора паттерна — Клиентское кэширование снижает нагрузку на сервер,
обеспечивая быстрый доступ к промежуточным результатам рендеринга на устройстве пользователя.
Результаты рендеринга доступны только конкретному пользователю, поэтому кэшировать их можно на стороне браузера клиента

- Способ инвалидации — инвалидация при внесении изменений в редакторе. 

4) **Кэшировать список заказов для операторов**

- Паттерн — Write-Through

- Обоснование выбора паттерна — проблемы с загрузкой страниц по заказам для операторов. 
Необходимо предоставлять только актуальные данные, поэтому кэш должен быть синхронизирован с базой данных. 
Так как допускается задержка того, что заказ у операторов появится не сразу,
вполне возможно обновлять и кэш и базу данных синхронно

- Способ инвалидации — инвалидация по ключу при каждом изменении статуса заказа. Допускается инвалидация по TTL.
Так как изменение точеченое, то нет смысла инвалидировать весь кэш. 

- Дополнительно возможно использование кэширование на стороне клиента с привязкой кэша к сессии.
  Это позволит предотвратить частые запросы на бэкенд при обновлении страниц.
  Кэш на стороне клиента будет инвалидироваться проставлением параметра TTL.


5) **Кэшировать загруженные файлы 3D-моделей**
- Паттерн — Cache-Aside

- Обоснование выбора паттерна — файлы не будут меняться после загрузки, 
в основном их будут скачивать. Нет необходимости в обновлении кэша при операциях записи, 
так как достаточно того, что новые данные будут добавлять в кэш при чтении

- Способ инвалидации — TTL. Другие способы инвалидации не подходят, так как файлы не будут меняться после загрузки.

6) **Кэшировать результат рендеринга готовых 3D-моделей**

- Паттерн — Cache-Aside

- Обоснование выбора паттерна — финальный результат рендеринга модели может никогда не меняться, но при этом этот результат
может быть нужен для отображения модели на UI и использоваться при подсчете стоимости.
Допустимо кэшировать результаты, используя паттерн Cache-Aside

- Способ инвалидации — TTL. Другие способы инвалидации не подходят, так как результаты не будут изменяться.